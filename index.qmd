---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---
## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?
Answer: The expected value of your account balance after one flip is $31,500. This is greater than $30,000, so this simple analysis suggests you should buy-in to the game.
The gain in expected value is $1,500, which is a 5% gain from your buy-in.
This line calculates the expected value (EV) of your wealth after one coin flip:
Heads (50% chance): Gain 50% -> 1.5 * 30000 = 45000
Tails (50% chance): Lose 40% -> 0.6 * 30000 = 18000
EV = 0.5 * 45000 + 0.5 * 18000 = 31500  which is greater than $30,000
So the EV is:
EV = 0.5 * 45000 + 0.5 * 18000 = 22,500 + 9,000 = 31,500
calculates the percentage gain compared to your starting wealth: (31500 - 30000) / 30000 = 0.05 = 5%
So the expected value is greater than $30,000, so this simple analysis suggests you should buy-in to the game.  


```{python}
#| label: q1-expected-value-py
#| echo: false

# TODO: Compute EV after one flip in Python
# - Show calculation and brief explanation
EV = 0.5 * 1.5 * 30000 + 0.5 * 0.6 * 30000
print(f"Expected Value after one flip: ${EV:.2f}")
print(f"Gain in expected value: {((EV - 30000) / 30000) * 100:.2f}%")
```

  ### 2) Single Simulation Over Time (Narrative + Plot)

  Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.
  Answer: I am not happy with the outcome. The account balance drops significantly by the end of the simulation. The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5). By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.

ðŸ“– **Narrative of the Simulation**
You begin the game with $30,000. Each year, you flip a fair coin:

If it lands Heads, your wealth increases by 50%

If it lands Tails, your wealth decreases by 40%

Over the course of 50 years, the randomness of the coin flips creates a volatile journey. In this particular run:

You experience a mix of gains and losses, with no consistent streak of wins

Early gains are quickly erased by subsequent losses

The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5)

By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.

ðŸ“‰ **Why This Outcome Is Unsatisfying**
Multiplicative games punish volatility: Even with a fair coin, alternating wins and losses shrink your wealth over time.

No guarantee of upward trajectory: Unlike traditional investments, this game lacks stability or compounding growth.

Most simulations trend downward unless you get lucky with many consecutive heads.

In short, while the game may seem mathematically promising, the real-world outcome is highly unstable and often disappointing.

ðŸ“Š **Why This Outcome Is Unsatisfying Visualization**
 view the time series plot. It shows:

- X-axis: Years from 0 to 50
- Y-axis: Wealth in dollars
- Line plot: Your account balance over time
```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

# Simulate one path from $30,000 over N periods
# - Make a matplotlib (OO) time-series
# - Set seed for reproducibility

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_steps = 50

# Simulate coin flips: 1 = heads (gain), 0 = tails (loss)
coin_flips = np.random.binomial(n=1, p=0.5, size=n_steps)

# Initialize wealth array
wealth = [initial_wealth]

# Simulate wealth evolution
for flip in coin_flips:
    if flip == 1:
        new_wealth = wealth[-1] * 1.5
    else:
        new_wealth = wealth[-1] * 0.6
    wealth.append(new_wealth)

# Plot using matplotlib's object-oriented interface
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(range(n_steps + 1), wealth, color='blue', label='Account Balance')
ax.set_title("Stochastic Investment Path Over Time")
ax.set_xlabel("Time Step")
ax.set_ylabel("Account Balance ($)")
ax.legend()
ax.grid(True)
plt.tight_layout()
plt.show()

```


### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?
Answer: An analysis of the results of 100 simulations of the investment game, where each run spans 30 to 50 years and starts with $30,000. Each year, a fair coin is flipped:

- Heads (50%) â†’ wealth increases by 50% (Ã—1.5)
- Tails (50%) â†’ wealth decreases by 40% (Ã—0.6)

ðŸ“Š **Distribution of Final Balances Analysis**
After running 100 simulations, we observe a highly skewed distribution:
- Most outcomes fall below the initial $30,000
- A few lucky runs end with very high balances (e.g., $100,000+)
- The histogram shows a long right tail, meaning rare but extreme gains

ðŸ“ˆ **Key Statistics Analysis**
Letâ€™s say the results were:
- Mean final balance	$83,785.58
- Median final balance	$2,153.69
- Probability final balance > $30k	24%
Interpretation:
Mean > $30k: Skewed by a few big wins

Median < $30k: Most runs end with less than you started

Only 24% of runs are profitable â†’ 76% chance of losing money    

ðŸ” **Why This Happens Analysis**
This game is multiplicative, not additive. That means:

One heads followed by one tails:

- One heads followed by one tails: 1.5 * 0.6 = 0.9
- You lose 10% of your wealth even with one win and one loss

- Over time, alternating wins and losses compound downward

- You need long streaks of heads to grow your wealth â€” which are statistically rare

ðŸš« **Investment Verdict Analysis**
Despite a positive expected value per flip, the game is:  Highly volatile, Unpredictable, Statistically unfavorable for most players
If you're risk-averse or seeking stable growth, this game is not a wise investment. It's more like gambling than investing.

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

# TODO: Run 100 simulations and plot histogram of final balances
# - Add vertical line at $30,000
# - Compute mean, median, and P(final > $30,000)
import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_steps = 50
n_simulations = 100

# Store final balances
final_balances = []

# Run simulations
for _ in range(n_simulations):
    wealth = initial_wealth
    coin_flips = np.random.binomial(n=1, p=0.5, size=n_steps)
    for flip in coin_flips:
        wealth *= 1.5 if flip == 1 else 0.6
    final_balances.append(wealth)

# Convert to numpy array for easier processing
data = np.array(final_balances)

# Compute statistics
mean_balance = np.mean(data)
median_balance = np.median(data)
prob_above_30k = np.mean(data > initial_wealth)

# Create log-spaced bins
bins = np.logspace(np.log10(data.min()), np.log10(data.max()), 30)

# Plot histogram with log-spaced bins
fig, ax = plt.subplots(figsize=(10, 6))
ax.hist(data, bins=bins, color='skyblue', edgecolor='black')
ax.axvline(initial_wealth, color='red', linestyle='dashed', linewidth=2, label='$30,000$ threshold')
ax.set_xscale('log')
ax.set_title("Log-Spaced Histogram of Final Balances After 100 Simulations")
ax.set_xlabel("Final Account Balance ($, log scale)")
ax.set_ylabel("Frequency")
ax.legend()
ax.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout()
plt.show()

# Print statistics
print(f"Mean final balance: ${mean_balance:,.2f}")
print(f"Median final balance: ${median_balance:,.2f}")
print(f"Probability final balance > $30,000: {prob_above_30k:.2%}")

```

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

Report the probability estimate and interpret its practical meaning.

ðŸ“Š **Probability Balance > $30,000 at Age 75 Analysis**

Using 100 simulations to get a robust estimate, we calculate the probability that your final balance exceeds the initial $30,000 investment after 50 years of playing the game.

**Key Finding:** The probability of ending with more than $30,000 is quite low, typically around 24% depending on the specific simulation run. This means approximately **76% of the time, you will end up with less money than you started with**, despite the game having a positive expected value per flip.

ðŸ“ˆ **What This Means in Practice**

- **Low success rate:** Only about 1 in 4 to 1 in 5 simulations result in a final balance above the initial investment
- **High failure rate:** About 3 in 4 to 4 in 5 simulations end with losses
- **Paradox of positive EV:** Even though each flip has a positive expected value (5% gain), most paths lead to losses over time

ðŸ§  **Why This Happens: The Multiplicative Volatility Trap**

The counterintuitive result occurs because of how multiplicative games work:

1. **Geometric mean vs. Arithmetic mean:**
   - Arithmetic mean (expected value per flip): $31,500 â†’ suggests you should play
   - Geometric mean (long-term growth): $\sqrt{1.5 \times 0.6} = \sqrt{0.9} = 0.949$ â†’ suggests you'll lose about 5% per flip pair
   
2. **The win-loss penalty:**
   - One heads followed by one tails: $30,000 \times 1.5 \times 0.6 = 30,000 \times 0.9 = $27,000
   - **You lose 10% even though you "broke even" on wins and losses!**
   
3. **Compounding volatility:**
   - Over 50 years, you need significantly more heads than tails to grow
   - With a fair coin, you're just as likely to get tails as heads
   - The occasional losses compound and drag down most paths

ðŸ“‰ **Distribution Characteristics**

- **Highly skewed:** Most outcomes are low, but a few lucky runs can be extremely high
- **Median < Mean:** The median is typically much lower than the mean, indicating most people lose
- **Long right tail:** Rare but extreme gains skew the average upward

ðŸš« **Investment Verdict**

This game demonstrates why **expected value alone is insufficient** for investment decisions in multiplicative scenarios:

- **Not recommended** for risk-averse investors
- **Not recommended** for retirement planning
- **High risk** with low probability of success
- The game is **statistically unfavorable** for most players despite positive EV

**Bottom line:** Even though the math suggests a positive expected value, the probability of actually ending up ahead is quite low. This is a perfect example of why risk management and understanding geometric returns matter more than simple expected value calculations.

```{python}
#| label: q4-prob-original-py
#| echo: false
#| fig-cap: "Probability Analysis: Final Balance > $30,000"

# Estimate P(final > 30000) using large-scale simulation
# - Print numeric result with 3 decimals
import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_years = 75  # Playing until age 75 (assuming starting around age 25)
n_simulations = 100 # Large sample for robust estimate

# Store final balances
final_balances = []

# Run simulations
for _ in range(n_simulations):
    wealth = initial_wealth
    # Simulate coin flips for each year: 1 = heads (+50%), 0 = tails (-40%)
    coin_flips = np.random.binomial(n=1, p=0.5, size=n_years)
    for flip in coin_flips:
        if flip == 1:  # Heads: increase by 50%
            wealth *= 1.5
        else:  # Tails: decrease by 40%
            wealth *= 0.6
    final_balances.append(wealth)

# Convert to numpy array for analysis
final_balances = np.array(final_balances)

# Compute statistics
prob_above_30k = np.mean(final_balances > initial_wealth)
prob_below_30k = 1 - prob_above_30k
mean_balance = np.mean(final_balances)
median_balance = np.median(final_balances)
std_balance = np.std(final_balances)

# Create visualization
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 6))

# Left plot: Histogram with probability region highlighted
min_val = final_balances.min()
max_val = final_balances.max()
bins = np.logspace(np.log10(min_val), np.log10(max_val), 50)

# Color code bars: green for above $30k, red for below
colors = ['red' if x < initial_wealth else 'green' for x in bins[:-1]]
n, bins_edges, patches = ax1.hist(final_balances, bins=bins, edgecolor='black', alpha=0.7)

# Color the bars
for patch, color in zip(patches, colors):
    patch.set_facecolor(color)
    patch.set_alpha(0.6)

ax1.axvline(initial_wealth, color='blue', linestyle='--', linewidth=3, 
            label=f'Initial Investment: ${initial_wealth:,}', zorder=10)
ax1.axvline(mean_balance, color='orange', linestyle=':', linewidth=2, 
            label=f'Mean: ${mean_balance:,.0f}')
ax1.axvline(median_balance, color='purple', linestyle=':', linewidth=2, 
            label=f'Median: ${median_balance:,.0f}')
ax1.set_xscale('log')
ax1.set_title('Distribution of Final Balances (100 Simulations)', 
              fontsize=13, fontweight='bold')
ax1.set_xlabel('Final Balance ($, log scale)', fontsize=12)
ax1.set_ylabel('Frequency', fontsize=12)
ax1.legend(fontsize=10, loc='upper left')
ax1.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

# Add text box with key statistics
textstr = f'Probability > ${initial_wealth:,}: {prob_above_30k:.1%}\n'
textstr += f'Probability < ${initial_wealth:,}: {prob_below_30k:.1%}\n'
textstr += f'Mean: ${mean_balance:,.0f}\n'
textstr += f'Median: ${median_balance:,.0f}'
props = dict(boxstyle='round', facecolor='wheat', alpha=0.8)
ax1.text(0.02, 0.98, textstr, transform=ax1.transAxes, fontsize=11,
         verticalalignment='top', bbox=props)

# Right plot: Probability comparison
categories = ['Above\n$30,000', 'Below\n$30,000']
probs = [prob_above_30k, prob_below_30k]
colors_bar = ['green', 'red']
bars = ax2.bar(categories, probs, color=colors_bar, alpha=0.7, 
               edgecolor='black', linewidth=2)

# Add value labels on bars
for bar, prob in zip(bars, probs):
    height = bar.get_height()
    ax2.text(bar.get_x() + bar.get_width()/2., height,
             f'{prob:.1%}', ha='center', va='bottom', 
             fontsize=14, fontweight='bold')

ax2.axhline(0.5, color='gray', linestyle=':', linewidth=1, alpha=0.5)
ax2.set_ylabel('Probability', fontsize=12)
ax2.set_title('Probability of Final Balance Relative to Initial Investment', 
              fontsize=13, fontweight='bold')
ax2.set_ylim(0, max(probs) * 1.15)
ax2.grid(True, axis='y', linestyle='--', linewidth=0.5, alpha=0.3)

plt.tight_layout()
plt.show()

# Print detailed results
print("=" * 70)
print("PROBABILITY ANALYSIS: Final Balance > $30,000 at Age 75")
print("=" * 70)
print(f"\nSimulation Parameters:")
print(f"  Initial investment:     ${initial_wealth:,}")
print(f"  Number of years:        {n_years}")
print(f"  Number of simulations:  {n_simulations:,}")
print(f"\nResults:")
print(f"  P(final > ${initial_wealth:,}):  {prob_above_30k:.3f} ({prob_above_30k:.1%})")
print(f"  P(final < ${initial_wealth:,}):  {prob_below_30k:.3f} ({prob_below_30k:.1%})")
print(f"\nSummary Statistics:")
print(f"  Mean final balance:     ${mean_balance:,.2f}")
print(f"  Median final balance:   ${median_balance:,.2f}")
print(f"  Std deviation:          ${std_balance:,.2f}")
print(f"\nInterpretation:")
print(f"  - Only {prob_above_30k:.1%} of simulations end above the initial investment")
print(f"  - {prob_below_30k:.1%} of simulations result in losses")
print(f"  - Despite positive expected value per flip, most paths lead to losses")
print("=" * 70)
```

### 5) Modified Strategy (Bet Exactly 25% Each Round)

Answer: Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

ðŸ“Š **Compare the original strategy (100% of balance at risk each year) with the modified strategy (only 25% of balance at risk per year) to understand the differences in risk and upside potential.**

ðŸŽ¯ **Setup Comparison**
- Strategy	Amount at Risk Each Year	Heads Outcome	Tails Outcome
- Original	100% of balance	Ã—1.5 (gain 50%)	Ã—0.6 (lose 40%)
- Modified (25% bet)	25% of balance	25% Ã— 1.5 + 75% = 1.125	25% Ã— 0.6 + 75% = 0.9
ðŸ“Š **Modified Strategy Math**
Each year:
- Heads:

- ð‘Šð‘¡ = ð‘Šð‘¡âˆ’1 â‹… (0.25 â‹… 1.5 + 0.75) = ð‘Šð‘¡âˆ’1 â‹… 1.125
- Tails:
- ð‘Šð‘¡ = ð‘Šð‘¡âˆ’1 â‹… (0.25 â‹… 0.6 + 0.75) = ð‘Šð‘¡âˆ’1 â‹… 0.9
- ð‘Šð‘¡ = ð‘Šð‘¡âˆ’1 â‹… 0.9
So instead of wild swings between Ã—1.5 and Ã—0.6, you now get: Moderate gain: +12.5% Moderate loss: âˆ’10%

ðŸ“ˆ **Which Is Riskier? Analysis**
Original strategy is much riskier:

- Full balance is exposed each year
- Large swings in wealth
- Most simulations end below the starting amount

Modified strategy is less risky:
- Only 25% of balance is exposed
- Smaller fluctuations
- Wealth decays more slowly on losses and grows more steadily on wins
ðŸš€ **Which Has Better Upside? Analysis**    
- Original strategy has higher upside: if you get lucky with many heads, your wealth can explode
- Modified strategy has lower upside: but more consistent growth and better protection against losses

ðŸ§  **Final Insight Analysis**
The modified strategy is less volatile and more stable, making it a better long-term approach for most investors. It sacrifices extreme gains for a much higher chance of preserving and growing wealth gradually.

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

# TODO: Implement the modified game
# - Run 100 simulations; plot distribution of final balances
# - Estimate P(final > 30000) and compare to original
# - visually compare the outcome distributions of the original and modified strategies
import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_steps = 50
n_simulations = 100

# Store final balances
original_final = []
modified_final = []

# Run simulations
for _ in range(n_simulations):
    # Original strategy
    wealth_orig = initial_wealth
    flips = np.random.binomial(n=1, p=0.5, size=n_steps)
    for flip in flips:
        wealth_orig *= 1.5 if flip == 1 else 0.6
    original_final.append(wealth_orig)

    # Modified strategy (25% at risk)
    wealth_mod = initial_wealth
    for flip in flips:
        risky = wealth_mod * 0.25
        safe = wealth_mod * 0.75
        risky *= 1.5 if flip == 1 else 0.6
        wealth_mod = risky + safe
    modified_final.append(wealth_mod)

# Convert to numpy arrays
original_final = np.array(original_final)
modified_final = np.array(modified_final)

# Compute statistics
mean_orig = np.mean(original_final)
median_orig = np.median(original_final)
p_orig = np.mean(original_final > initial_wealth)

mean_mod = np.mean(modified_final)
median_mod = np.median(modified_final)
p_mod = np.mean(modified_final > initial_wealth)

# Print summary statistics
print("=" * 60)
print("COMPARISON SUMMARY")
print("=" * 60)
print(f"\nOriginal Strategy:")
print(f"  Mean final balance:    ${mean_orig:,.2f}")
print(f"  Median final balance:  ${median_orig:,.2f}")
print(f"  P(final > $30,000):    {p_orig:.2%}")
print(f"\nModified Strategy (25% at risk):")
print(f"  Mean final balance:    ${mean_mod:,.2f}")
print(f"  Median final balance:  ${median_mod:,.2f}")
print(f"  P(final > $30,000):    {p_mod:.2%}")
print("=" * 60)

# Create clearer visualization with multiple views
fig = plt.figure(figsize=(16, 10))

# 1. Overlay histogram comparison (main view)
ax1 = plt.subplot(2, 2, 1)
min_val = min(original_final.min(), modified_final.min())
max_val = max(original_final.max(), modified_final.max())
bins = np.logspace(np.log10(min_val), np.log10(max_val), 40)

ax1.hist(original_final, bins=bins, color='coral', edgecolor='darkred', 
         alpha=0.6, label=f'Original (P(>$30k)={p_orig:.1%})', density=True)
ax1.hist(modified_final, bins=bins, color='steelblue', edgecolor='darkblue', 
         alpha=0.6, label=f'Modified 25% (P(>$30k)={p_mod:.1%})', density=True)
ax1.axvline(initial_wealth, color='red', linestyle='--', linewidth=2.5, 
            label=f'Initial: ${initial_wealth:,}', zorder=10)
ax1.set_xscale('log')
ax1.set_title('Distribution Comparison (Overlay)', fontsize=13, fontweight='bold')
ax1.set_xlabel('Final Balance ($, log scale)', fontsize=11)
ax1.set_ylabel('Density', fontsize=11)
ax1.legend(fontsize=10, loc='upper left')
ax1.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

# 2. Side-by-side box plots
ax2 = plt.subplot(2, 2, 2)
box_data = [original_final, modified_final]
bp = ax2.boxplot(box_data, labels=['Original', 'Modified\n(25% Risk)'], 
                 patch_artist=True, widths=0.6)
bp['boxes'][0].set_facecolor('coral')
bp['boxes'][1].set_facecolor('steelblue')
ax2.axhline(initial_wealth, color='red', linestyle='--', linewidth=2, 
            label=f'${initial_wealth:,}')
ax2.set_yscale('log')
ax2.set_title('Summary Statistics Comparison', fontsize=13, fontweight='bold')
ax2.set_ylabel('Final Balance ($, log scale)', fontsize=11)
ax2.legend(fontsize=10)
ax2.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

# 3. Probability comparison bar chart
ax3 = plt.subplot(2, 2, 3)
strategies = ['Original', 'Modified\n(25% Risk)']
probs = [p_orig, p_mod]
colors = ['coral', 'steelblue']
bars = ax3.bar(strategies, probs, color=colors, alpha=0.7, edgecolor='black', linewidth=2)
ax3.axhline(0.5, color='gray', linestyle=':', linewidth=1, alpha=0.5)
ax3.set_ylabel('Probability', fontsize=11)
ax3.set_title('P(Final Balance > $30,000)', fontsize=13, fontweight='bold')
ax3.set_ylim(0, max(probs) * 1.2)
# Add value labels on bars
for bar, prob in zip(bars, probs):
    height = bar.get_height()
    ax3.text(bar.get_x() + bar.get_width()/2., height,
             f'{prob:.1%}', ha='center', va='bottom', fontsize=11, fontweight='bold')
ax3.grid(True, axis='y', linestyle='--', linewidth=0.5, alpha=0.3)

# 4. Mean and Median comparison
ax4 = plt.subplot(2, 2, 4)
stats_names = ['Mean', 'Median']
orig_stats = [mean_orig, median_orig]
mod_stats = [mean_mod, median_mod]
x = np.arange(len(stats_names))
width = 0.35
bars1 = ax4.bar(x - width/2, orig_stats, width, label='Original', 
                color='coral', alpha=0.7, edgecolor='darkred', linewidth=1.5)
bars2 = ax4.bar(x + width/2, mod_stats, width, label='Modified (25%)', 
                color='steelblue', alpha=0.7, edgecolor='darkblue', linewidth=1.5)
ax4.axhline(initial_wealth, color='red', linestyle='--', linewidth=2, 
            label=f'Initial: ${initial_wealth:,}')
ax4.set_yscale('log')
ax4.set_ylabel('Final Balance ($, log scale)', fontsize=11)
ax4.set_title('Mean vs Median Comparison', fontsize=13, fontweight='bold')
ax4.set_xticks(x)
ax4.set_xticklabels(stats_names)
ax4.legend(fontsize=10)
ax4.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

plt.tight_layout()
plt.show()


```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"

What is the Kelly Criterion and how does it relate to the modified strategy?

ðŸ“š **What is the Kelly Criterion?**

The Kelly Criterion is a mathematical formula that determines the optimal fraction of wealth to bet in order to maximize long-term growth rate. Developed by John L. Kelly Jr. in 1956, it tells you how much to risk on each bet to maximize your expected logarithmic utility.

**The Kelly Formula:**
For a bet with:
- **p** = probability of winning (0.5 in our coin flip)
- **b** = net odds received on the wager (0.5 = gain 50%)
- **a** = net odds you lose (0.4 = lose 40%)

The optimal Kelly fraction is:
$$f^* = \frac{pb - (1-p)a}{b}$$

ðŸ§® **Kelly Criterion for Our Investment Game**

Let's calculate the Kelly optimal fraction for our coin flip game:

- **p = 0.5** (fair coin, 50% chance of heads)
- **b = 0.5** (heads: gain 50%)
- **a = 0.4** (tails: lose 40%)

$$f^* = \frac{0.5 \times 0.5 - 0.5 \times 0.4}{0.5} = \frac{0.25 - 0.20}{0.5} = \frac{0.05}{0.5} = 0.10 = 10\%$$

**Result:** The Kelly Criterion suggests betting **10% of your wealth** each round, not 100% (original strategy) or 25% (modified strategy).

ðŸ” **How This Relates to Our Strategies**

1. **Original Strategy (100% at risk):** This is **10Ã— the Kelly optimal**! This is extremely aggressive and explains why most simulations end with losses. You're overbetting by a factor of 10.

2. **Modified Strategy (25% at risk):** This is **2.5Ã— the Kelly optimal**. While better than the original, it's still overbetting and exposes you to unnecessary risk.

3. **Kelly Optimal Strategy (10% at risk):** This would maximize long-term growth rate while avoiding excessive risk.

ðŸ’¡ **Key Insights**

- **Why the original strategy fails:** Betting 100% creates extreme volatility. Even though the expected value per flip is positive, the geometric mean (which determines long-term growth) suffers from overbetting.
  
- **Why the modified strategy is better:** Reducing risk to 25% improves outcomes, but it's still too aggressive compared to Kelly optimal (10%).

- **The Kelly advantage:** Betting at the Kelly fraction maximizes the expected logarithmic utility, which translates to maximizing long-term wealth growth while avoiding ruin.

ðŸ“Š **Practical Interpretation**

The Kelly Criterion shows us that:
- **Less is often more** in multiplicative games
- **Risk management matters more than maximizing expected value** in repeated bets
- **The "optimal" bet size is usually much smaller** than intuition suggests

The modified strategy (25%) moves in the right direction but could be improved further by using the Kelly optimal fraction of 10%.

```{python}
#| label: q6-kelly-criterion-py
#| echo: false
#| fig-cap: "Kelly Criterion: Comparison of different betting fractions"

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Calculate Kelly optimal fraction
p = 0.5  # probability of win
b = 0.5  # gain 50% on win
a = 0.4  # lose 40% on loss

kelly_fraction = (p * b - (1 - p) * a) / b
print(f"Kelly Optimal Fraction: {kelly_fraction:.1%}")
print(f"Formula: f* = (pÃ—b - (1-p)Ã—a) / b = ({p}Ã—{b} - {1-p}Ã—{a}) / {b} = {kelly_fraction:.1%}\n")

# Simulate different betting fractions including Kelly optimal
betting_fractions = [0.10, 0.25, 0.50, 1.0]  # 10% (Kelly), 25% (modified), 50%, 100% (original)
fraction_labels = ['10% (Kelly)', '25% (Modified)', '50%', '100% (Original)']
initial_wealth = 30000
n_years = 75  # Play until age 75
n_simulations = 100  # Use 100 simulations for robust comparison

results = {}

# Run simulations for each betting fraction
for fraction in betting_fractions:
    final_balances = []
    
    for _ in range(n_simulations):
        wealth = initial_wealth
        coin_flips = np.random.binomial(n=1, p=0.5, size=n_years)
        
        for flip in coin_flips:
            risky = wealth * fraction
            safe = wealth * (1 - fraction)
            
            if flip == 1:  # Heads: gain 50%
                risky *= 1.5
            else:  # Tails: lose 40%
                risky *= 0.6
            
            wealth = risky + safe
        final_balances.append(wealth)
    
    final_balances = np.array(final_balances)
    results[fraction] = final_balances

# Create comprehensive visualization
fig = plt.figure(figsize=(16, 12))

# 1. Distribution comparison (histograms)
axes_hist = []
for i in range(4):
    ax = plt.subplot(3, 2, i+1)
    axes_hist.append(ax)
    
    fraction = betting_fractions[i]
    final_balances = results[fraction]
    
    min_val = final_balances.min()
    max_val = final_balances.max()
    bins = np.logspace(np.log10(min_val), np.log10(max_val), 30)
    
    mean_val = np.mean(final_balances)
    median_val = np.median(final_balances)
    prob_above = np.mean(final_balances > initial_wealth)
    kelly_ratio = fraction / kelly_fraction
    
    # Color code: Kelly optimal gets special color
    color = 'green' if fraction == kelly_fraction else 'steelblue'
    
    ax.hist(final_balances, bins=bins, color=color, edgecolor='black', alpha=0.7)
    ax.axvline(initial_wealth, color='red', linestyle='--', linewidth=2, 
               label=f'Initial: ${initial_wealth:,}')
    ax.axvline(mean_val, color='orange', linestyle=':', linewidth=2, 
               label=f'Mean: ${mean_val:,.0f}')
    ax.set_xscale('log')
    ax.set_title(f'{fraction_labels[i]} ({fraction:.0%})\n'
                 f'Mean: ${mean_val:,.0f} | Median: ${median_val:,.0f}\n'
                 f'P(>$30k): {prob_above:.1%} | Kelly Ratio: {kelly_ratio:.1f}Ã—', 
                 fontsize=10, fontweight='bold')
    ax.set_xlabel('Final Balance ($, log scale)')
    ax.set_ylabel('Frequency')
    ax.legend(fontsize=8)
    ax.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

# 2. Summary comparison: Probability of success
ax5 = plt.subplot(3, 2, 5)
probs = [np.mean(results[f] > initial_wealth) for f in betting_fractions]
colors_bar = ['green' if f == kelly_fraction else 'steelblue' for f in betting_fractions]
bars = ax5.bar(fraction_labels, probs, color=colors_bar, alpha=0.7, 
               edgecolor='black', linewidth=2)
ax5.axhline(0.5, color='gray', linestyle=':', linewidth=1, alpha=0.5)
ax5.set_ylabel('Probability', fontsize=11)
ax5.set_title('Probability of Final Balance > $30,000', fontsize=12, fontweight='bold')
ax5.set_ylim(0, max(probs) * 1.2)
# Add value labels
for bar, prob in zip(bars, probs):
    height = bar.get_height()
    ax5.text(bar.get_x() + bar.get_width()/2., height,
             f'{prob:.1%}', ha='center', va='bottom', 
             fontsize=10, fontweight='bold')
ax5.grid(True, axis='y', linestyle='--', linewidth=0.5, alpha=0.3)
plt.setp(ax5.xaxis.get_majorticklabels(), rotation=45, ha='right')

# 3. Summary comparison: Median final balance
ax6 = plt.subplot(3, 2, 6)
medians = [np.median(results[f]) for f in betting_fractions]
bars = ax6.bar(fraction_labels, medians, color=colors_bar, alpha=0.7, 
               edgecolor='black', linewidth=2)
ax6.axhline(initial_wealth, color='red', linestyle='--', linewidth=2, 
            label=f'Initial: ${initial_wealth:,}')
ax6.set_yscale('log')
ax6.set_ylabel('Median Final Balance ($, log scale)', fontsize=11)
ax6.set_title('Median Final Balance by Betting Fraction', fontsize=12, fontweight='bold')
ax6.legend(fontsize=9)
ax6.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)
plt.setp(ax6.xaxis.get_majorticklabels(), rotation=45, ha='right')

plt.suptitle('Kelly Criterion Analysis: Impact of Betting Fraction on Final Wealth (75 Years)', 
             fontsize=14, fontweight='bold', y=0.995)
plt.tight_layout()
plt.show()

# Print comprehensive comparison table
print("\n" + "=" * 80)
print("KELLY CRITERION: COMPREHENSIVE COMPARISON OF BETTING FRACTIONS")
print("=" * 80)
print(f"{'Strategy':<20} {'Fraction':<12} {'Mean':<15} {'Median':<15} {'P(>$30k)':<12} {'Kelly Ratio':<12}")
print("-" * 80)
for i, fraction in enumerate(betting_fractions):
    data = results[fraction]
    mean_val = np.mean(data)
    median_val = np.median(data)
    prob_above = np.mean(data > initial_wealth)
    kelly_ratio = fraction / kelly_fraction
    strategy_name = fraction_labels[i]
    print(f"{strategy_name:<20} {fraction:>6.0%}     ${mean_val:>12,.0f}   "
          f"${median_val:>12,.0f}   {prob_above:>10.1%}    {kelly_ratio:>6.1f}Ã—")
print("=" * 80)
print(f"\nKelly Optimal Fraction: {kelly_fraction:.1%} (1.0Ã—)")
print("\nKey Insights:")
print(f"  â€¢ Original strategy (100%) is {1.0/kelly_fraction:.1f}Ã— the Kelly optimal â†’ EXTREMELY AGGRESSIVE")
print(f"  â€¢ Modified strategy (25%) is {0.25/kelly_fraction:.1f}Ã— the Kelly optimal â†’ Still overbetting")
print(f"  â€¢ Kelly optimal (10%) maximizes long-term growth rate")
print("\nInterpretation:")
print("  â€¢ Values > 1.0Ã— are overbetting (too aggressive, higher volatility, lower median)")
print("  â€¢ Values < 1.0Ã— are underbetting (too conservative, lower growth potential)")
print("  â€¢ Kelly optimal (1.0Ã—) balances growth and risk optimally")
print("=" * 80)









