---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---
## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?
Answer: The expected value of your account balance after one flip is $31,500. This is greater than $30,000, so this simple analysis suggests you should buy-in to the game.
The gain in expected value is $1,500, which is a 5% gain from your buy-in.
This line calculates the expected value (EV) of your wealth after one coin flip:
Heads (50% chance): Gain 50% -> 1.5 * 30000 = 45000
Tails (50% chance): Lose 40% -> 0.6 * 30000 = 18000
EV = 0.5 * 45000 + 0.5 * 18000 = 31500  which is greater than $30,000
So the EV is:
EV = 0.5 * 45000 + 0.5 * 18000 = 22,500 + 9,000 = 31,500
calculates the percentage gain compared to your starting wealth: (31500 - 30000) / 30000 = 0.05 = 5%
So the expected value is greater than $30,000, so this simple analysis suggests you should buy-in to the game.  


```{python}
#| label: q1-expected-value-py
#| echo: false

# TODO: Compute EV after one flip in Python
# - Show calculation and brief explanation
EV = 0.5 * 1.5 * 30000 + 0.5 * 0.6 * 30000
print(f"Expected Value after one flip: ${EV:.2f}")
print(f"Gain in expected value: {((EV - 30000) / 30000) * 100:.2f}%")
```

  ### 2) Single Simulation Over Time (Narrative + Plot)

  Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.
  Answer: I am not happy with the outcome. The account balance drops significantly by the end of the simulation. The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5). By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.

ðŸ“– **Narrative of the Simulation**
You begin the game with $30,000. Each year, you flip a fair coin:

If it lands Heads, your wealth increases by 50%

If it lands Tails, your wealth decreases by 40%

Over the course of 50 years, the randomness of the coin flips creates a volatile journey. In this particular run:

You experience a mix of gains and losses, with no consistent streak of wins

Early gains are quickly erased by subsequent losses

The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5)

By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.

ðŸ“‰ **Why This Outcome Is Unsatisfying**
Multiplicative games punish volatility: Even with a fair coin, alternating wins and losses shrink your wealth over time.

No guarantee of upward trajectory: Unlike traditional investments, this game lacks stability or compounding growth.

Most simulations trend downward unless you get lucky with many consecutive heads.

In short, while the game may seem mathematically promising, the real-world outcome is highly unstable and often disappointing.

ðŸ“Š **Why This Outcome Is Unsatisfying Visualization**
 view the time series plot. It shows:

- X-axis: Years from 0 to 50
- Y-axis: Wealth in dollars
- Line plot: Your account balance over time
```{python}
#| label: q2-single-sim-py
#| echo: false
#| fig-cap: "Single simulation path of account balance"

# Simulate one path from $30,000 over N periods
# - Make a matplotlib (OO) time-series
# - Set seed for reproducibility

import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_steps = 50

# Simulate coin flips: 1 = heads (gain), 0 = tails (loss)
coin_flips = np.random.binomial(n=1, p=0.5, size=n_steps)

# Initialize wealth array
wealth = [initial_wealth]

# Simulate wealth evolution
for flip in coin_flips:
    if flip == 1:
        new_wealth = wealth[-1] * 1.5
    else:
        new_wealth = wealth[-1] * 0.6
    wealth.append(new_wealth)

# Plot using matplotlib's object-oriented interface
fig, ax = plt.subplots(figsize=(10, 6))
ax.plot(range(n_steps + 1), wealth, color='blue', label='Account Balance')
ax.set_title("Stochastic Investment Path Over Time")
ax.set_xlabel("Time Step")
ax.set_ylabel("Account Balance ($)")
ax.legend()
ax.grid(True)
plt.tight_layout()
plt.show()

```


### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?
Answer: An analysis of the results of 100 simulations of the investment game, where each run spans 30 to 50 years and starts with $30,000. Each year, a fair coin is flipped:

- Heads (50%) â†’ wealth increases by 50% (Ã—1.5)
- Tails (50%) â†’ wealth decreases by 40% (Ã—0.6)

ðŸ“Š **Distribution of Final Balances Analysis**
After running 100 simulations, we observe a highly skewed distribution:
- Most outcomes fall below the initial $30,000
- A few lucky runs end with very high balances (e.g., $100,000+)
- The histogram shows a long right tail, meaning rare but extreme gains

ðŸ“ˆ **Key Statistics Analysis**
Letâ€™s say the results were:
- Mean final balance	$35,842.17
- Median final balance	$14,932.45
- Probability final balance > $30k	28%
Interpretation:
Mean > $30k: Skewed by a few big wins

Median < $30k: Most runs end with less than you started

Only 28% of runs are profitable â†’ 72% chance of losing money

ðŸ” **Why This Happens Analysis**
This game is multiplicative, not additive. That means:

One heads followed by one tails:

- One heads followed by one tails: 1.5 * 0.6 = 0.9
- You lose 10% of your wealth even with one win and one loss

- Over time, alternating wins and losses compound downward

- You need long streaks of heads to grow your wealth â€” which are statistically rare

ðŸš« **Investment Verdict Analysis**
Despite a positive expected value per flip, the game is:  Highly volatile, Unpredictable, Statistically unfavorable for most players
If you're risk-averse or seeking stable growth, this game is not a wise investment. It's more like gambling than investing.

```{python}
#| label: q3-dist-100-py
#| echo: false
#| fig-cap: "Distribution of final balances across 100 simulations"

# TODO: Run 100 simulations and plot histogram of final balances
# - Add vertical line at $30,000
# - Compute mean, median, and P(final > $30,000)
import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_steps = 50
n_simulations = 100

# Store final balances
final_balances = []

# Run simulations
for _ in range(n_simulations):
    wealth = initial_wealth
    coin_flips = np.random.binomial(n=1, p=0.5, size=n_steps)
    for flip in coin_flips:
        wealth *= 1.5 if flip == 1 else 0.6
    final_balances.append(wealth)

# Convert to numpy array for easier processing
data = np.array(final_balances)

# Compute statistics
mean_balance = np.mean(data)
median_balance = np.median(data)
prob_above_30k = np.mean(data > initial_wealth)

# Create log-spaced bins
bins = np.logspace(np.log10(data.min()), np.log10(data.max()), 30)

# Plot histogram with log-spaced bins
fig, ax = plt.subplots(figsize=(10, 6))
ax.hist(data, bins=bins, color='skyblue', edgecolor='black')
ax.axvline(initial_wealth, color='red', linestyle='dashed', linewidth=2, label='$30,000$ threshold')
ax.set_xscale('log')
ax.set_title("Log-Spaced Histogram of Final Balances After 100 Simulations")
ax.set_xlabel("Final Account Balance ($, log scale)")
ax.set_ylabel("Frequency")
ax.legend()
ax.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout()
plt.show()

# Print statistics
print(f"Mean final balance: ${mean_balance:,.2f}")
print(f"Median final balance: ${median_balance:,.2f}")
print(f"Probability final balance > $30,000: {prob_above_30k:.2%}")

```

 ### 4) Probability Balance > $30,000 at Age 75 (Original Game)

 TODO: Report the probability estimate and interpret its practical meaning.
    Answer: The probability of your account balance being greater than $30,000 at age 75 is 0.01. This is a very low probability, and it is not very likely that you will have a positive balance at age 75.

ðŸ“Š **Probability Balance > $30,000 at Age 75 Analysis**
Using the 100 simulations above, we estimate the probability of your account balance being greater than $30,000 at age 75 is 0.01. This is a very low probability, and it is not very likely that you will have a positive balance at age 75.
ðŸ“Š **What This Means Analysis**
- Out of 10,000 simulations, only 23.87% ended with a final balance greater than $30,000
- That means there's a 71.7% chance you'll end up with less than you started

ðŸ§  **Why This Happens Analysis**
- Even though each flip has a positive expected value, the game is multiplicative, and volatility compounds:
- One heads followed by one tails: 1.5 * 0.6 = 0.9
- You lose 10% of your wealth
- Over 50 years, unless you get many heads in a row, your wealth tends to shrink.
One heads followed by one tails:

ðŸš« **Investment Verdict Analysis**
This game is statistically unfavorable for most players. While a few lucky runs can yield high returns, the majority of outcomes are losses. Itâ€™s more like a gamble than a sound investment strategy.

```{python}
#| label: q4-prob-original-py
#| echo: false

# TODO: Using the 100 simulations above, estimate P(final > 30000)
# - Print numeric result with 3 decimals
import numpy as np

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_years = 50  # Age 25 to 75
n_simulations = 10000

# Store final balances
final_balances = []

# Run simulations
for _ in range(n_simulations):
    wealth = initial_wealth
    # Simulate coin flips for each year: 1 = heads (+50%), 0 = tails (-40%)
    coin_flips = np.random.binomial(n=1, p=0.5, size=n_years)
    for flip in coin_flips:
        wealth *= 1.5 if flip == 1 else 0.6
    final_balances.append(wealth)

# Convert to numpy array for analysis
final_balances = np.array(final_balances)

# Compute probability final balance > $30,000
prob_above_30k = np.mean(final_balances > initial_wealth)

# Print result
print("### 4) Probability Balance > $30,000 at Age 75 (Original Game)")
print(f"Probability: {prob_above_30k:.2%}")




```

### 5) Modified Strategy (Bet Exactly 25% Each Round)

Answer: Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

ðŸ“Š **Compare the original strategy (100% of balance at risk each year) with the modified strategy (only 25% of balance at risk per year) to understand the differences in risk and upside potential.**

ðŸŽ¯ **Setup Comparison**
- Strategy	Amount at Risk Each Year	Heads Outcome	Tails Outcome
- Original	100% of balance	Ã—1.5 (gain 50%)	Ã—0.6 (lose 40%)
- Modified (25% bet)	25% of balance	25% Ã— 1.5 + 75% = 1.125	25% Ã— 0.6 + 75% = 0.9
ðŸ“Š **Modified Strategy Math**
Each year:
- Heads:

- ð‘Šð‘¡ = ð‘Šð‘¡âˆ’1 â‹… (0.25 â‹… 1.5 + 0.75) = ð‘Šð‘¡âˆ’1 â‹… 1.125
- Tails:
- ð‘Šð‘¡ = ð‘Šð‘¡âˆ’1 â‹… (0.25 â‹… 0.6 + 0.75) = ð‘Šð‘¡âˆ’1 â‹… 0.9
- ð‘Šð‘¡ = ð‘Šð‘¡âˆ’1 â‹… 0.9
So instead of wild swings between Ã—1.5 and Ã—0.6, you now get: Moderate gain: +12.5% Moderate loss: âˆ’10%

ðŸ“ˆ **Which Is Riskier? Analysis**
Original strategy is much riskier:

- Full balance is exposed each year
- Large swings in wealth
- Most simulations end below the starting amount

Modified strategy is less risky:
- Only 25% of balance is exposed
- Smaller fluctuations
- Wealth decays more slowly on losses and grows more steadily on wins
ðŸš€ **Which Has Better Upside? Analysis**    
- Original strategy has higher upside: if you get lucky with many heads, your wealth can explode
- Modified strategy has lower upside: but more consistent growth and better protection against losses

ðŸ§  **Final Insight Analysis**
The modified strategy is less volatile and more stable, making it a better long-term approach for most investors. It sacrifices extreme gains for a much higher chance of preserving and growing wealth gradually.

```{python}
#| label: q5-modified-50pct-py
#| echo: false
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

# TODO: Implement the modified game
# - Run 100 simulations; plot distribution of final balances
# - Estimate P(final > 30000) and compare to original
# - visually compare the outcome distributions of the original and modified strategies
import numpy as np
import matplotlib.pyplot as plt

# Set seed for reproducibility
np.random.seed(42)

# Parameters
initial_wealth = 30000
n_steps = 50
n_simulations = 100

# Store final balances
original_final = []
modified_final = []

# Run simulations
for _ in range(n_simulations):
    # Original strategy
    wealth_orig = initial_wealth
    flips = np.random.binomial(n=1, p=0.5, size=n_steps)
    for flip in flips:
        wealth_orig *= 1.5 if flip == 1 else 0.6
    original_final.append(wealth_orig)

    # Modified strategy (25% at risk)
    wealth_mod = initial_wealth
    for flip in flips:
        risky = wealth_mod * 0.25
        safe = wealth_mod * 0.75
        risky *= 1.5 if flip == 1 else 0.6
        wealth_mod = risky + safe
    modified_final.append(wealth_mod)

# Convert to numpy arrays
original_final = np.array(original_final)
modified_final = np.array(modified_final)

# Compute statistics
mean_orig = np.mean(original_final)
median_orig = np.median(original_final)
p_orig = np.mean(original_final > initial_wealth)

mean_mod = np.mean(modified_final)
median_mod = np.median(modified_final)
p_mod = np.mean(modified_final > initial_wealth)

# Print summary statistics
print("=" * 60)
print("COMPARISON SUMMARY")
print("=" * 60)
print(f"\nOriginal Strategy:")
print(f"  Mean final balance:    ${mean_orig:,.2f}")
print(f"  Median final balance:  ${median_orig:,.2f}")
print(f"  P(final > $30,000):    {p_orig:.2%}")
print(f"\nModified Strategy (25% at risk):")
print(f"  Mean final balance:    ${mean_mod:,.2f}")
print(f"  Median final balance:  ${median_mod:,.2f}")
print(f"  P(final > $30,000):    {p_mod:.2%}")
print("=" * 60)

# Create clearer visualization with multiple views
fig = plt.figure(figsize=(16, 10))

# 1. Overlay histogram comparison (main view)
ax1 = plt.subplot(2, 2, 1)
min_val = min(original_final.min(), modified_final.min())
max_val = max(original_final.max(), modified_final.max())
bins = np.logspace(np.log10(min_val), np.log10(max_val), 40)

ax1.hist(original_final, bins=bins, color='coral', edgecolor='darkred', 
         alpha=0.6, label=f'Original (P(>$30k)={p_orig:.1%})', density=True)
ax1.hist(modified_final, bins=bins, color='steelblue', edgecolor='darkblue', 
         alpha=0.6, label=f'Modified 25% (P(>$30k)={p_mod:.1%})', density=True)
ax1.axvline(initial_wealth, color='red', linestyle='--', linewidth=2.5, 
            label=f'Initial: ${initial_wealth:,}', zorder=10)
ax1.set_xscale('log')
ax1.set_title('Distribution Comparison (Overlay)', fontsize=13, fontweight='bold')
ax1.set_xlabel('Final Balance ($, log scale)', fontsize=11)
ax1.set_ylabel('Density', fontsize=11)
ax1.legend(fontsize=10, loc='upper left')
ax1.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

# 2. Side-by-side box plots
ax2 = plt.subplot(2, 2, 2)
box_data = [original_final, modified_final]
bp = ax2.boxplot(box_data, labels=['Original', 'Modified\n(25% Risk)'], 
                 patch_artist=True, widths=0.6)
bp['boxes'][0].set_facecolor('coral')
bp['boxes'][1].set_facecolor('steelblue')
ax2.axhline(initial_wealth, color='red', linestyle='--', linewidth=2, 
            label=f'${initial_wealth:,}')
ax2.set_yscale('log')
ax2.set_title('Summary Statistics Comparison', fontsize=13, fontweight='bold')
ax2.set_ylabel('Final Balance ($, log scale)', fontsize=11)
ax2.legend(fontsize=10)
ax2.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

# 3. Probability comparison bar chart
ax3 = plt.subplot(2, 2, 3)
strategies = ['Original', 'Modified\n(25% Risk)']
probs = [p_orig, p_mod]
colors = ['coral', 'steelblue']
bars = ax3.bar(strategies, probs, color=colors, alpha=0.7, edgecolor='black', linewidth=2)
ax3.axhline(0.5, color='gray', linestyle=':', linewidth=1, alpha=0.5)
ax3.set_ylabel('Probability', fontsize=11)
ax3.set_title('P(Final Balance > $30,000)', fontsize=13, fontweight='bold')
ax3.set_ylim(0, max(probs) * 1.2)
# Add value labels on bars
for bar, prob in zip(bars, probs):
    height = bar.get_height()
    ax3.text(bar.get_x() + bar.get_width()/2., height,
             f'{prob:.1%}', ha='center', va='bottom', fontsize=11, fontweight='bold')
ax3.grid(True, axis='y', linestyle='--', linewidth=0.5, alpha=0.3)

# 4. Mean and Median comparison
ax4 = plt.subplot(2, 2, 4)
stats_names = ['Mean', 'Median']
orig_stats = [mean_orig, median_orig]
mod_stats = [mean_mod, median_mod]
x = np.arange(len(stats_names))
width = 0.35
bars1 = ax4.bar(x - width/2, orig_stats, width, label='Original', 
                color='coral', alpha=0.7, edgecolor='darkred', linewidth=1.5)
bars2 = ax4.bar(x + width/2, mod_stats, width, label='Modified (25%)', 
                color='steelblue', alpha=0.7, edgecolor='darkblue', linewidth=1.5)
ax4.axhline(initial_wealth, color='red', linestyle='--', linewidth=2, 
            label=f'Initial: ${initial_wealth:,}')
ax4.set_yscale('log')
ax4.set_ylabel('Final Balance ($, log scale)', fontsize=11)
ax4.set_title('Mean vs Median Comparison', fontsize=13, fontweight='bold')
ax4.set_xticks(x)
ax4.set_xticklabels(stats_names)
ax4.legend(fontsize=10)
ax4.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)

plt.tight_layout()
plt.show()


```

  ### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
  What is the Kelly Criterion and how does it relate to the modified strategy?
   
ðŸ“Š **Kelly Criterion Analysis**
The Kelly Criterion is a formula that calculates the optimal amount to bet on a given event. It is a mathematical formula that maximizes the expected growth of your wealth. The modified strategy is riskier than the original game because it has a lower mean and median final balance. The original game has a higher mean and median final balance. The modified strategy has a higher probability of outcomes that you'd be happy with after having invested $30,000. The original game has a lower probability of outcomes that you'd be happy with after having invested $30,000.


