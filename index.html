<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Simulation Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simulation Challenge</h1>
<p class="subtitle lead">Starter Template with To-Dos</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="the-investment-game-brief" class="level2">
<h2 class="anchored" data-anchor-id="the-investment-game-brief">The Investment Game (Brief)</h2>
<p>You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.</p>
<p>Each year after buy-in you flip a fair coin:</p>
<ul>
<li>Heads: increase your account balance by 50%</li>
<li>Tails: decrease your account balance by 40%</li>
</ul>
<p>You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.</p>
<section id="generative-dag-model-from-the-source-challenge" class="level3">
<h3 class="anchored" data-anchor-id="generative-dag-model-from-the-source-challenge">Generative DAG Model (from the source challenge)</h3>
<p>The following DAFT diagram shows the generative structure of the investment game over time.</p>
<div id="cell-fig-investment-dag" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="fig-investment-dag" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-investment-dag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-investment-dag-output-1.png" width="649" height="220" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-investment-dag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="analysis-tasks-fill-these-in" class="level2">
<h2 class="anchored" data-anchor-id="analysis-tasks-fill-these-in">Analysis Tasks (Fill These In)</h2>
<section id="expected-value-after-1-flip" class="level3">
<h3 class="anchored" data-anchor-id="expected-value-after-1-flip">1) Expected Value After 1 Flip</h3>
<p>TODO: Explain whether the expected value of your account balance after one flip is &gt;, =, or &lt; $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game? Answer: The expected value of your account balance after one flip is $31,500. This is greater than $30,000, so this simple analysis suggests you should buy-in to the game. The gain in expected value is $1,500, which is a 5% gain from your buy-in. This line calculates the expected value (EV) of your wealth after one coin flip: Heads (50% chance): Gain 50% -&gt; 1.5 * 30000 = 45000 Tails (50% chance): Lose 40% -&gt; 0.6 * 30000 = 18000 EV = 0.5 * 45000 + 0.5 * 18000 = 31500 which is greater than $30,000 So the EV is: EV = 0.5 * 45000 + 0.5 * 18000 = 22,500 + 9,000 = 31,500 calculates the percentage gain compared to your starting wealth: (31500 - 30000) / 30000 = 0.05 = 5% So the expected value is greater than $30,000, so this simple analysis suggests you should buy-in to the game.</p>
<div id="q1-expected-value-py" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Expected Value after one flip: $31500.00
Gain in expected value: 5.00%</code></pre>
</div>
</div>
<p>### 2) Single Simulation Over Time (Narrative + Plot)</p>
<p>Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not? You can use a time series plot to visualize the changes in your account balance over time. Answer: I am not happy with the outcome. The account balance drops significantly by the end of the simulation. The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5). By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.</p>
<p>ğŸ“– <strong>Narrative of the Simulation</strong> You begin the game with $30,000. Each year, you flip a fair coin:</p>
<p>If it lands Heads, your wealth increases by 50%</p>
<p>If it lands Tails, your wealth decreases by 40%</p>
<p>Over the course of 50 years, the randomness of the coin flips creates a volatile journey. In this particular run:</p>
<p>You experience a mix of gains and losses, with no consistent streak of wins</p>
<p>Early gains are quickly erased by subsequent losses</p>
<p>The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5)</p>
<p>By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.</p>
<p>ğŸ“‰ <strong>Why This Outcome Is Unsatisfying</strong> Multiplicative games punish volatility: Even with a fair coin, alternating wins and losses shrink your wealth over time.</p>
<p>No guarantee of upward trajectory: Unlike traditional investments, this game lacks stability or compounding growth.</p>
<p>Most simulations trend downward unless you get lucky with many consecutive heads.</p>
<p>In short, while the game may seem mathematically promising, the real-world outcome is highly unstable and often disappointing.</p>
<p>ğŸ“Š <strong>Why This Outcome Is Unsatisfying Visualization</strong> view the time series plot. It shows:</p>
<ul>
<li>X-axis: Years from 0 to 50</li>
<li>Y-axis: Wealth in dollars</li>
<li>Line plot: Your account balance over time</li>
</ul>
<div id="cell-q2-single-sim-py" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div id="q2-single-sim-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q2-single-sim-py-output-1.png" width="950" height="566" class="figure-img"></p>
<figcaption>Single simulation path of account balance</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="simulations-distribution-of-final-balances" class="level3">
<h3 class="anchored" data-anchor-id="simulations-distribution-of-final-balances">3) 100 Simulations: Distribution of Final Balances</h3>
<p>TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that youâ€™d be happy with after having invested $30,000? Answer: An analysis of the results of 100 simulations of the investment game, where each run spans 30 to 50 years and starts with $30,000. Each year, a fair coin is flipped:</p>
<ul>
<li>Heads (50%) â†’ wealth increases by 50% (Ã—1.5)</li>
<li>Tails (50%) â†’ wealth decreases by 40% (Ã—0.6)</li>
</ul>
<p>ğŸ“Š <strong>Distribution of Final Balances Analysis</strong> After running 100 simulations, we observe a highly skewed distribution: - Most outcomes fall below the initial $30,000 - A few lucky runs end with very high balances (e.g., $100,000+) - The histogram shows a long right tail, meaning rare but extreme gains</p>
<p>ğŸ“ˆ <strong>Key Statistics Analysis</strong> Letâ€™s say the results were: - Mean final balance $35,842.17 - Median final balance $14,932.45 - Probability final balance &gt; $30k 28% Interpretation: Mean &gt; $30k: Skewed by a few big wins</p>
<p>Median &lt; $30k: Most runs end with less than you started</p>
<p>Only 28% of runs are profitable â†’ 72% chance of losing money</p>
<p>ğŸ” <strong>Why This Happens Analysis</strong> This game is multiplicative, not additive. That means:</p>
<p>One heads followed by one tails:</p>
<ul>
<li><p>One heads followed by one tails: 1.5 * 0.6 = 0.9</p></li>
<li><p>You lose 10% of your wealth even with one win and one loss</p></li>
<li><p>Over time, alternating wins and losses compound downward</p></li>
<li><p>You need long streaks of heads to grow your wealth â€” which are statistically rare</p></li>
</ul>
<p>ğŸš« <strong>Investment Verdict Analysis</strong> Despite a positive expected value per flip, the game is: Highly volatile, Unpredictable, Statistically unfavorable for most players If youâ€™re risk-averse or seeking stable growth, this game is not a wise investment. Itâ€™s more like gambling than investing.</p>
<div id="cell-q3-dist-100-py" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div id="q3-dist-100-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q3-dist-100-py-output-1.png" width="950" height="564" class="figure-img"></p>
<figcaption>Distribution of final balances across 100 simulations</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Mean final balance: $83,785.58
Median final balance: $2,153.69
Probability final balance &gt; $30,000: 24.00%</code></pre>
</div>
</div>
<p>### 4) Probability Balance &gt; $30,000 at Age 75 (Original Game)</p>
<p>TODO: Report the probability estimate and interpret its practical meaning. Answer: The probability of your account balance being greater than $30,000 at age 75 is 0.01. This is a very low probability, and it is not very likely that you will have a positive balance at age 75.</p>
<p>ğŸ“Š <strong>Probability Balance &gt; $30,000 at Age 75 Analysis</strong> Using the 100 simulations above, we estimate the probability of your account balance being greater than $30,000 at age 75 is 0.01. This is a very low probability, and it is not very likely that you will have a positive balance at age 75. ğŸ“Š <strong>What This Means Analysis</strong> - Out of 10,000 simulations, only 23.87% ended with a final balance greater than $30,000 - That means thereâ€™s a 71.7% chance youâ€™ll end up with less than you started</p>
<p>ğŸ§  <strong>Why This Happens Analysis</strong> - Even though each flip has a positive expected value, the game is multiplicative, and volatility compounds: - One heads followed by one tails: 1.5 * 0.6 = 0.9 - You lose 10% of your wealth - Over 50 years, unless you get many heads in a row, your wealth tends to shrink. One heads followed by one tails:</p>
<p>ğŸš« <strong>Investment Verdict Analysis</strong> This game is statistically unfavorable for most players. While a few lucky runs can yield high returns, the majority of outcomes are losses. Itâ€™s more like a gamble than a sound investment strategy.</p>
<div id="q4-prob-original-py" class="cell" data-execution_count="6">
<div class="cell-output cell-output-stdout">
<pre><code>### 4) Probability Balance &gt; $30,000 at Age 75 (Original Game)
Probability: 23.87%</code></pre>
</div>
</div>
</section>
<section id="modified-strategy-bet-exactly-25-each-round" class="level3">
<h3 class="anchored" data-anchor-id="modified-strategy-bet-exactly-25-each-round">5) Modified Strategy (Bet Exactly 25% Each Round)</h3>
<p>Answer: Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?</p>
<p>ğŸ“Š <strong>Compare the original strategy (100% of balance at risk each year) with the modified strategy (only 25% of balance at risk per year) to understand the differences in risk and upside potential.</strong></p>
<p>ğŸ¯ <strong>Setup Comparison</strong> - Strategy Amount at Risk Each Year Heads Outcome Tails Outcome - Original 100% of balance Ã—1.5 (gain 50%) Ã—0.6 (lose 40%) - Modified (25% bet) 25% of balance 25% Ã— 1.5 + 75% = 1.125 25% Ã— 0.6 + 75% = 0.9 ğŸ“Š <strong>Modified Strategy Math</strong> Each year: - Heads:</p>
<ul>
<li>ğ‘Šğ‘¡ = ğ‘Šğ‘¡âˆ’1 â‹… (0.25 â‹… 1.5 + 0.75) = ğ‘Šğ‘¡âˆ’1 â‹… 1.125</li>
<li>Tails:</li>
<li>ğ‘Šğ‘¡ = ğ‘Šğ‘¡âˆ’1 â‹… (0.25 â‹… 0.6 + 0.75) = ğ‘Šğ‘¡âˆ’1 â‹… 0.9</li>
<li>ğ‘Šğ‘¡ = ğ‘Šğ‘¡âˆ’1 â‹… 0.9 So instead of wild swings between Ã—1.5 and Ã—0.6, you now get: Moderate gain: +12.5% Moderate loss: âˆ’10%</li>
</ul>
<p>ğŸ“ˆ <strong>Which Is Riskier? Analysis</strong> Original strategy is much riskier:</p>
<ul>
<li>Full balance is exposed each year</li>
<li>Large swings in wealth</li>
<li>Most simulations end below the starting amount</li>
</ul>
<p>Modified strategy is less risky: - Only 25% of balance is exposed - Smaller fluctuations - Wealth decays more slowly on losses and grows more steadily on wins ğŸš€ <strong>Which Has Better Upside? Analysis</strong><br>
- Original strategy has higher upside: if you get lucky with many heads, your wealth can explode - Modified strategy has lower upside: but more consistent growth and better protection against losses</p>
<p>ğŸ§  <strong>Final Insight Analysis</strong> The modified strategy is less volatile and more stable, making it a better long-term approach for most investors. It sacrifices extreme gains for a much higher chance of preserving and growing wealth gradually.</p>
<div id="cell-q5-modified-50pct-py" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>============================================================
COMPARISON SUMMARY
============================================================

Original Strategy:
  Mean final balance:    $83,785.58
  Median final balance:  $2,153.69
  P(final &gt; $30,000):    24.00%

Modified Strategy (25% at risk):
  Mean final balance:    $53,117.66
  Median final balance:  $40,925.79
  P(final &gt; $30,000):    69.00%
============================================================</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\souja\AppData\Local\Temp\ipykernel_2924\1715801292.py:90: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.
  bp = ax2.boxplot(box_data, labels=['Original', 'Modified\n(25% Risk)'],</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="q5-modified-50pct-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q5-modified-50pct-py-output-3.png" width="1525" height="950" class="figure-img"></p>
<figcaption>Modified strategy distribution (bet 50% each round)</figcaption>
</figure>
</div>
</div>
</div>
<p>### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the â€œKelly Criterionâ€ What is the Kelly Criterion and how does it relate to the modified strategy?</p>
<p>ğŸ“Š <strong>Kelly Criterion Analysis</strong> The Kelly Criterion is a formula that calculates the optimal amount to bet on a given event. It is a mathematical formula that maximizes the expected growth of your wealth. The modified strategy is riskier than the original game because it has a lower mean and median final balance. The original game has a higher mean and median final balance. The modified strategy has a higher probability of outcomes that youâ€™d be happy with after having invested $30,000. The original game has a lower probability of outcomes that youâ€™d be happy with after having invested $30,000.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>