<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Simulation Challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="index_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="index_files/libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap-9e3ffae467580fdb927a41352e75a2e0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Simulation Challenge</h1>
<p class="subtitle lead">Starter Template with To-Dos</p>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="the-investment-game-brief" class="level2">
<h2 class="anchored" data-anchor-id="the-investment-game-brief">The Investment Game (Brief)</h2>
<p>You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.</p>
<p>Each year after buy-in you flip a fair coin:</p>
<ul>
<li>Heads: increase your account balance by 50%</li>
<li>Tails: decrease your account balance by 40%</li>
</ul>
<p>You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.</p>
<section id="generative-dag-model-from-the-source-challenge" class="level3">
<h3 class="anchored" data-anchor-id="generative-dag-model-from-the-source-challenge">Generative DAG Model (from the source challenge)</h3>
<p>The following DAFT diagram shows the generative structure of the investment game over time.</p>
<div id="cell-fig-investment-dag" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="fig-investment-dag" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-investment-dag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="index_files/figure-html/fig-investment-dag-output-1.png" width="649" height="220" class="figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-investment-dag-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="analysis-tasks-fill-these-in" class="level2">
<h2 class="anchored" data-anchor-id="analysis-tasks-fill-these-in">Analysis Tasks (Fill These In)</h2>
<section id="expected-value-after-1-flip" class="level3">
<h3 class="anchored" data-anchor-id="expected-value-after-1-flip">1) Expected Value After 1 Flip</h3>
<p>TODO: Explain whether the expected value of your account balance after one flip is &gt;, =, or &lt; $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game? Answer: The expected value of your account balance after one flip is $31,500. This is greater than $30,000, so this simple analysis suggests you should buy-in to the game. The gain in expected value is $1,500, which is a 5% gain from your buy-in. This line calculates the expected value (EV) of your wealth after one coin flip: Heads (50% chance): Gain 50% -&gt; 1.5 * 30000 = 45000 Tails (50% chance): Lose 40% -&gt; 0.6 * 30000 = 18000 EV = 0.5 * 45000 + 0.5 * 18000 = 31500 which is greater than $30,000 So the EV is: EV = 0.5 * 45000 + 0.5 * 18000 = 22,500 + 9,000 = 31,500 calculates the percentage gain compared to your starting wealth: (31500 - 30000) / 30000 = 0.05 = 5% So the expected value is greater than $30,000, so this simple analysis suggests you should buy-in to the game.</p>
<div id="q1-expected-value-py" class="cell" data-execution_count="3">
<div class="cell-output cell-output-stdout">
<pre><code>Expected Value after one flip: $31500.00
Gain in expected value: 5.00%</code></pre>
</div>
</div>
<p>### 2) Single Simulation Over Time (Narrative + Plot)</p>
<p>Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not? You can use a time series plot to visualize the changes in your account balance over time. Answer: I am not happy with the outcome. The account balance drops significantly by the end of the simulation. The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5). By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.</p>
<p>ğŸ“– <strong>Narrative of the Simulation</strong> You begin the game with $30,000. Each year, you flip a fair coin:</p>
<p>If it lands Heads, your wealth increases by 50%</p>
<p>If it lands Tails, your wealth decreases by 40%</p>
<p>Over the course of 50 years, the randomness of the coin flips creates a volatile journey. In this particular run:</p>
<p>You experience a mix of gains and losses, with no consistent streak of wins</p>
<p>Early gains are quickly erased by subsequent losses</p>
<p>The compounding effect of repeated losses (multiplying by 0.6) outweighs the occasional gains (multiplying by 1.5)</p>
<p>By the end of the simulation, your wealth has dropped significantly, despite the game having a positive expected value per flip.</p>
<p>ğŸ“‰ <strong>Why This Outcome Is Unsatisfying</strong> Multiplicative games punish volatility: Even with a fair coin, alternating wins and losses shrink your wealth over time.</p>
<p>No guarantee of upward trajectory: Unlike traditional investments, this game lacks stability or compounding growth.</p>
<p>Most simulations trend downward unless you get lucky with many consecutive heads.</p>
<p>In short, while the game may seem mathematically promising, the real-world outcome is highly unstable and often disappointing.</p>
<p>ğŸ“Š <strong>Why This Outcome Is Unsatisfying Visualization</strong> view the time series plot. It shows:</p>
<ul>
<li>X-axis: Years from 0 to 50</li>
<li>Y-axis: Wealth in dollars</li>
<li>Line plot: Your account balance over time</li>
</ul>
<div id="cell-q2-single-sim-py" class="cell" data-execution_count="4">
<div class="cell-output cell-output-display">
<div id="q2-single-sim-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q2-single-sim-py-output-1.png" width="950" height="566" class="figure-img"></p>
<figcaption>Single simulation path of account balance</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="simulations-distribution-of-final-balances" class="level3">
<h3 class="anchored" data-anchor-id="simulations-distribution-of-final-balances">3) 100 Simulations: Distribution of Final Balances</h3>
<p>TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that youâ€™d be happy with after having invested $30,000? Answer: An analysis of the results of 100 simulations of the investment game, where each run spans 30 to 50 years and starts with $30,000. Each year, a fair coin is flipped:</p>
<ul>
<li>Heads (50%) â†’ wealth increases by 50% (Ã—1.5)</li>
<li>Tails (50%) â†’ wealth decreases by 40% (Ã—0.6)</li>
</ul>
<p>ğŸ“Š <strong>Distribution of Final Balances Analysis</strong> After running 100 simulations, we observe a highly skewed distribution: - Most outcomes fall below the initial $30,000 - A few lucky runs end with very high balances (e.g., $100,000+) - The histogram shows a long right tail, meaning rare but extreme gains</p>
<p>ğŸ“ˆ <strong>Key Statistics Analysis</strong> Letâ€™s say the results were: - Mean final balance $83,785.58 - Median final balance $2,153.69 - Probability final balance &gt; $30k 24% Interpretation: Mean &gt; $30k: Skewed by a few big wins</p>
<p>Median &lt; $30k: Most runs end with less than you started</p>
<p>Only 24% of runs are profitable â†’ 76% chance of losing money</p>
<p>ğŸ” <strong>Why This Happens Analysis</strong> This game is multiplicative, not additive. That means:</p>
<p>One heads followed by one tails:</p>
<ul>
<li><p>One heads followed by one tails: 1.5 * 0.6 = 0.9</p></li>
<li><p>You lose 10% of your wealth even with one win and one loss</p></li>
<li><p>Over time, alternating wins and losses compound downward</p></li>
<li><p>You need long streaks of heads to grow your wealth â€” which are statistically rare</p></li>
</ul>
<p>ğŸš« <strong>Investment Verdict Analysis</strong> Despite a positive expected value per flip, the game is: Highly volatile, Unpredictable, Statistically unfavorable for most players If youâ€™re risk-averse or seeking stable growth, this game is not a wise investment. Itâ€™s more like gambling than investing.</p>
<div id="cell-q3-dist-100-py" class="cell" data-execution_count="5">
<div class="cell-output cell-output-display">
<div id="q3-dist-100-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q3-dist-100-py-output-1.png" width="950" height="564" class="figure-img"></p>
<figcaption>Distribution of final balances across 100 simulations</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Mean final balance: $83,785.58
Median final balance: $2,153.69
Probability final balance &gt; $30,000: 24.00%</code></pre>
</div>
</div>
</section>
<section id="probability-balance-30000-at-age-75-original-game" class="level3">
<h3 class="anchored" data-anchor-id="probability-balance-30000-at-age-75-original-game">4) Probability Balance &gt; $30,000 at Age 75 (Original Game)</h3>
<p>Report the probability estimate and interpret its practical meaning.</p>
<p>ğŸ“Š <strong>Probability Balance &gt; $30,000 at Age 75 Analysis</strong></p>
<p>Using 100 simulations to get a robust estimate, we calculate the probability that your final balance exceeds the initial $30,000 investment after 50 years of playing the game.</p>
<p><strong>Key Finding:</strong> The probability of ending with more than $30,000 is quite low, typically around 24% depending on the specific simulation run. This means approximately <strong>76% of the time, you will end up with less money than you started with</strong>, despite the game having a positive expected value per flip.</p>
<p>ğŸ“ˆ <strong>What This Means in Practice</strong></p>
<ul>
<li><strong>Low success rate:</strong> Only about 1 in 4 to 1 in 5 simulations result in a final balance above the initial investment</li>
<li><strong>High failure rate:</strong> About 3 in 4 to 4 in 5 simulations end with losses</li>
<li><strong>Paradox of positive EV:</strong> Even though each flip has a positive expected value (5% gain), most paths lead to losses over time</li>
</ul>
<p>ğŸ§  <strong>Why This Happens: The Multiplicative Volatility Trap</strong></p>
<p>The counterintuitive result occurs because of how multiplicative games work:</p>
<ol type="1">
<li><strong>Geometric mean vs.&nbsp;Arithmetic mean:</strong>
<ul>
<li>Arithmetic mean (expected value per flip): $31,500 â†’ suggests you should play</li>
<li>Geometric mean (long-term growth): <span class="math inline">\(\sqrt{1.5 \times 0.6} = \sqrt{0.9} = 0.949\)</span> â†’ suggests youâ€™ll lose about 5% per flip pair</li>
</ul></li>
<li><strong>The win-loss penalty:</strong>
<ul>
<li>One heads followed by one tails: $30,000 = 30,000 = $27,000</li>
<li><strong>You lose 10% even though you â€œbroke evenâ€ on wins and losses!</strong></li>
</ul></li>
<li><strong>Compounding volatility:</strong>
<ul>
<li>Over 50 years, you need significantly more heads than tails to grow</li>
<li>With a fair coin, youâ€™re just as likely to get tails as heads</li>
<li>The occasional losses compound and drag down most paths</li>
</ul></li>
</ol>
<p>ğŸ“‰ <strong>Distribution Characteristics</strong></p>
<ul>
<li><strong>Highly skewed:</strong> Most outcomes are low, but a few lucky runs can be extremely high</li>
<li><strong>Median &lt; Mean:</strong> The median is typically much lower than the mean, indicating most people lose</li>
<li><strong>Long right tail:</strong> Rare but extreme gains skew the average upward</li>
</ul>
<p>ğŸš« <strong>Investment Verdict</strong></p>
<p>This game demonstrates why <strong>expected value alone is insufficient</strong> for investment decisions in multiplicative scenarios:</p>
<ul>
<li><strong>Not recommended</strong> for risk-averse investors</li>
<li><strong>Not recommended</strong> for retirement planning</li>
<li><strong>High risk</strong> with low probability of success</li>
<li>The game is <strong>statistically unfavorable</strong> for most players despite positive EV</li>
</ul>
<p><strong>Bottom line:</strong> Even though the math suggests a positive expected value, the probability of actually ending up ahead is quite low. This is a perfect example of why risk management and understanding geometric returns matter more than simple expected value calculations.</p>
<div id="cell-q4-prob-original-py" class="cell" data-execution_count="6">
<div class="cell-output cell-output-display">
<div id="q4-prob-original-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q4-prob-original-py-output-1.png" width="1527" height="564" class="figure-img"></p>
<figcaption>Probability Analysis: Final Balance &gt; $30,000</figcaption>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>======================================================================
PROBABILITY ANALYSIS: Final Balance &gt; $30,000 at Age 75
======================================================================

Simulation Parameters:
  Initial investment:     $30,000
  Number of years:        75
  Number of simulations:  100

Results:
  P(final &gt; $30,000):  0.110 (11.0%)
  P(final &lt; $30,000):  0.890 (89.0%)

Summary Statistics:
  Mean final balance:     $67,234.54
  Median final balance:   $364.96
  Std deviation:          $375,801.30

Interpretation:
  - Only 11.0% of simulations end above the initial investment
  - 89.0% of simulations result in losses
  - Despite positive expected value per flip, most paths lead to losses
======================================================================</code></pre>
</div>
</div>
</section>
<section id="modified-strategy-bet-exactly-25-each-round" class="level3">
<h3 class="anchored" data-anchor-id="modified-strategy-bet-exactly-25-each-round">5) Modified Strategy (Bet Exactly 25% Each Round)</h3>
<p>Answer: Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?</p>
<p>ğŸ“Š <strong>Compare the original strategy (100% of balance at risk each year) with the modified strategy (only 25% of balance at risk per year) to understand the differences in risk and upside potential.</strong></p>
<p>ğŸ¯ <strong>Setup Comparison</strong> - Strategy Amount at Risk Each Year Heads Outcome Tails Outcome - Original 100% of balance Ã—1.5 (gain 50%) Ã—0.6 (lose 40%) - Modified (25% bet) 25% of balance 25% Ã— 1.5 + 75% = 1.125 25% Ã— 0.6 + 75% = 0.9 ğŸ“Š <strong>Modified Strategy Math</strong> Each year: - Heads:</p>
<ul>
<li>ğ‘Šğ‘¡ = ğ‘Šğ‘¡âˆ’1 â‹… (0.25 â‹… 1.5 + 0.75) = ğ‘Šğ‘¡âˆ’1 â‹… 1.125</li>
<li>Tails:</li>
<li>ğ‘Šğ‘¡ = ğ‘Šğ‘¡âˆ’1 â‹… (0.25 â‹… 0.6 + 0.75) = ğ‘Šğ‘¡âˆ’1 â‹… 0.9</li>
<li>ğ‘Šğ‘¡ = ğ‘Šğ‘¡âˆ’1 â‹… 0.9 So instead of wild swings between Ã—1.5 and Ã—0.6, you now get: Moderate gain: +12.5% Moderate loss: âˆ’10%</li>
</ul>
<p>ğŸ“ˆ <strong>Which Is Riskier? Analysis</strong> Original strategy is much riskier:</p>
<ul>
<li>Full balance is exposed each year</li>
<li>Large swings in wealth</li>
<li>Most simulations end below the starting amount</li>
</ul>
<p>Modified strategy is less risky: - Only 25% of balance is exposed - Smaller fluctuations - Wealth decays more slowly on losses and grows more steadily on wins ğŸš€ <strong>Which Has Better Upside? Analysis</strong><br>
- Original strategy has higher upside: if you get lucky with many heads, your wealth can explode - Modified strategy has lower upside: but more consistent growth and better protection against losses</p>
<p>ğŸ§  <strong>Final Insight Analysis</strong> The modified strategy is less volatile and more stable, making it a better long-term approach for most investors. It sacrifices extreme gains for a much higher chance of preserving and growing wealth gradually.</p>
<div id="cell-q5-modified-50pct-py" class="cell" data-execution_count="7">
<div class="cell-output cell-output-stdout">
<pre><code>============================================================
COMPARISON SUMMARY
============================================================

Original Strategy:
  Mean final balance:    $83,785.58
  Median final balance:  $2,153.69
  P(final &gt; $30,000):    24.00%

Modified Strategy (25% at risk):
  Mean final balance:    $53,117.66
  Median final balance:  $40,925.79
  P(final &gt; $30,000):    69.00%
============================================================</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\souja\AppData\Local\Temp\ipykernel_45104\1715801292.py:90: MatplotlibDeprecationWarning: The 'labels' parameter of boxplot() has been renamed 'tick_labels' since Matplotlib 3.9; support for the old name will be dropped in 3.11.
  bp = ax2.boxplot(box_data, labels=['Original', 'Modified\n(25% Risk)'],</code></pre>
</div>
<div class="cell-output cell-output-display">
<div id="q5-modified-50pct-py" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="index_files/figure-html/q5-modified-50pct-py-output-3.png" width="1525" height="950" class="figure-img"></p>
<figcaption>Modified strategy distribution (bet 50% each round)</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="briefly-explain-your-findings-from-the-previous-step-in-light-of-a-concept-known-as-the-kelly-criterion" class="level3">
<h3 class="anchored" data-anchor-id="briefly-explain-your-findings-from-the-previous-step-in-light-of-a-concept-known-as-the-kelly-criterion">6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the â€œKelly Criterionâ€</h3>
<p>What is the Kelly Criterion and how does it relate to the modified strategy?</p>
<p>ğŸ“š <strong>What is the Kelly Criterion?</strong></p>
<p>The Kelly Criterion is a mathematical formula that determines the optimal fraction of wealth to bet in order to maximize long-term growth rate. Developed by John L. Kelly Jr.&nbsp;in 1956, it tells you how much to risk on each bet to maximize your expected logarithmic utility.</p>
<p><strong>The Kelly Formula:</strong> For a bet with: - <strong>p</strong> = probability of winning (0.5 in our coin flip) - <strong>b</strong> = net odds received on the wager (0.5 = gain 50%) - <strong>a</strong> = net odds you lose (0.4 = lose 40%)</p>
<p>The optimal Kelly fraction is: <span class="math display">\[f^* = \frac{pb - (1-p)a}{b}\]</span></p>
<p>ğŸ§® <strong>Kelly Criterion for Our Investment Game</strong></p>
<p>Letâ€™s calculate the Kelly optimal fraction for our coin flip game:</p>
<ul>
<li><strong>p = 0.5</strong> (fair coin, 50% chance of heads)</li>
<li><strong>b = 0.5</strong> (heads: gain 50%)</li>
<li><strong>a = 0.4</strong> (tails: lose 40%)</li>
</ul>
<p><span class="math display">\[f^* = \frac{0.5 \times 0.5 - 0.5 \times 0.4}{0.5} = \frac{0.25 - 0.20}{0.5} = \frac{0.05}{0.5} = 0.10 = 10\%\]</span></p>
<p><strong>Result:</strong> The Kelly Criterion suggests betting <strong>10% of your wealth</strong> each round, not 100% (original strategy) or 25% (modified strategy).</p>
<p>ğŸ” <strong>How This Relates to Our Strategies</strong></p>
<ol type="1">
<li><p><strong>Original Strategy (100% at risk):</strong> This is <strong>10Ã— the Kelly optimal</strong>! This is extremely aggressive and explains why most simulations end with losses. Youâ€™re overbetting by a factor of 10.</p></li>
<li><p><strong>Modified Strategy (25% at risk):</strong> This is <strong>2.5Ã— the Kelly optimal</strong>. While better than the original, itâ€™s still overbetting and exposes you to unnecessary risk.</p></li>
<li><p><strong>Kelly Optimal Strategy (10% at risk):</strong> This would maximize long-term growth rate while avoiding excessive risk.</p></li>
</ol>
<p>ğŸ’¡ <strong>Key Insights</strong></p>
<ul>
<li><p><strong>Why the original strategy fails:</strong> Betting 100% creates extreme volatility. Even though the expected value per flip is positive, the geometric mean (which determines long-term growth) suffers from overbetting.</p></li>
<li><p><strong>Why the modified strategy is better:</strong> Reducing risk to 25% improves outcomes, but itâ€™s still too aggressive compared to Kelly optimal (10%).</p></li>
<li><p><strong>The Kelly advantage:</strong> Betting at the Kelly fraction maximizes the expected logarithmic utility, which translates to maximizing long-term wealth growth while avoiding ruin.</p></li>
</ul>
<p>ğŸ“Š <strong>Practical Interpretation</strong></p>
<p>The Kelly Criterion shows us that: - <strong>Less is often more</strong> in multiplicative games - <strong>Risk management matters more than maximizing expected value</strong> in repeated bets - <strong>The â€œoptimalâ€ bet size is usually much smaller</strong> than intuition suggests</p>
<p>The modified strategy (25%) moves in the right direction but could be improved further by using the Kelly optimal fraction of 10%.</p>
<p>#| label: q6-kelly-criterion-py #| echo: false #| fig-cap: â€œKelly Criterion: Comparison of different betting fractionsâ€</p>
<p>import numpy as np import matplotlib.pyplot as plt</p>
</section>
</section>
<section id="set-seed-for-reproducibility" class="level1">
<h1>Set seed for reproducibility</h1>
<p>np.random.seed(42)</p>
</section>
<section id="calculate-kelly-optimal-fraction" class="level1">
<h1>Calculate Kelly optimal fraction</h1>
<p>p = 0.5 # probability of win b = 0.5 # gain 50% on win a = 0.4 # lose 40% on loss</p>
<p>kelly_fraction = (p * b - (1 - p) * a) / b print(fâ€Kelly Optimal Fraction: {kelly_fraction:.1%}â€œ) print(fâ€Formula: f* = (pÃ—b - (1-p)Ã—a) / b = ({p}Ã—{b} - {1-p}Ã—{a}) / {b} = {kelly_fraction:.1%}â€œ)</p>
</section>
<section id="simulate-different-betting-fractions-including-kelly-optimal" class="level1">
<h1>Simulate different betting fractions including Kelly optimal</h1>
<p>betting_fractions = [0.10, 0.25, 0.50, 1.0] # 10% (Kelly), 25% (modified), 50%, 100% (original) fraction_labels = [â€˜10% (Kelly)â€™, â€˜25% (Modified)â€™, â€˜50%â€™, â€˜100% (Original)â€™] initial_wealth = 30000 n_years = 75 # Play until age 75 n_simulations = 100 # Use 100 simulations for robust comparison</p>
<p>results = {}</p>
</section>
<section id="run-simulations-for-each-betting-fraction" class="level1">
<h1>Run simulations for each betting fraction</h1>
<p>for fraction in betting_fractions: final_balances = []</p>
<pre><code>for _ in range(n_simulations):
    wealth = initial_wealth
    coin_flips = np.random.binomial(n=1, p=0.5, size=n_years)
    
    for flip in coin_flips:
        risky = wealth * fraction
        safe = wealth * (1 - fraction)
        
        if flip == 1:  # Heads: gain 50%
            risky *= 1.5
        else:  # Tails: lose 40%
            risky *= 0.6
        
        wealth = risky + safe
    final_balances.append(wealth)

final_balances = np.array(final_balances)
results[fraction] = final_balances</code></pre>
</section>
<section id="create-comprehensive-visualization" class="level1">
<h1>Create comprehensive visualization</h1>
<p>fig = plt.figure(figsize=(16, 12))</p>
</section>
<section id="distribution-comparison-histograms" class="level1">
<h1>1. Distribution comparison (histograms)</h1>
<p>axes_hist = [] for i in range(4): ax = plt.subplot(3, 2, i+1) axes_hist.append(ax)</p>
<pre><code>fraction = betting_fractions[i]
final_balances = results[fraction]

min_val = final_balances.min()
max_val = final_balances.max()
bins = np.logspace(np.log10(min_val), np.log10(max_val), 30)

mean_val = np.mean(final_balances)
median_val = np.median(final_balances)
prob_above = np.mean(final_balances &gt; initial_wealth)
kelly_ratio = fraction / kelly_fraction

# Color code: Kelly optimal gets special color
color = 'green' if fraction == kelly_fraction else 'steelblue'

ax.hist(final_balances, bins=bins, color=color, edgecolor='black', alpha=0.7)
ax.axvline(initial_wealth, color='red', linestyle='--', linewidth=2, 
           label=f'Initial: ${initial_wealth:,}')
ax.axvline(mean_val, color='orange', linestyle=':', linewidth=2, 
           label=f'Mean: ${mean_val:,.0f}')
ax.set_xscale('log')
ax.set_title(f'{fraction_labels[i]} ({fraction:.0%})\n'
             f'Mean: ${mean_val:,.0f} | Median: ${median_val:,.0f}\n'
             f'P(&gt;$30k): {prob_above:.1%} | Kelly Ratio: {kelly_ratio:.1f}Ã—', 
             fontsize=10, fontweight='bold')
ax.set_xlabel('Final Balance ($, log scale)')
ax.set_ylabel('Frequency')
ax.legend(fontsize=8)
ax.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)</code></pre>
</section>
<section id="summary-comparison-probability-of-success" class="level1">
<h1>2. Summary comparison: Probability of success</h1>
<p>ax5 = plt.subplot(3, 2, 5) probs = [np.mean(results[f] &gt; initial_wealth) for f in betting_fractions] colors_bar = [â€˜greenâ€™ if f == kelly_fraction else â€˜steelblueâ€™ for f in betting_fractions] bars = ax5.bar(fraction_labels, probs, color=colors_bar, alpha=0.7, edgecolor=â€˜blackâ€™, linewidth=2) ax5.axhline(0.5, color=â€˜grayâ€™, linestyle=â€˜:â€™, linewidth=1, alpha=0.5) ax5.set_ylabel(â€˜Probabilityâ€™, fontsize=11) ax5.set_title(â€˜Probability of Final Balance &gt; $30,000â€™, fontsize=12, fontweight=â€˜boldâ€™) ax5.set_ylim(0, max(probs) * 1.2) # Add value labels for bar, prob in zip(bars, probs): height = bar.get_height() ax5.text(bar.get_x() + bar.get_width()/2., height, fâ€™{prob:.1%}â€˜, ha=â€™centerâ€™, va=â€˜bottomâ€™, fontsize=10, fontweight=â€˜boldâ€™) ax5.grid(True, axis=â€˜yâ€™, linestyle=â€˜â€“â€™, linewidth=0.5, alpha=0.3) plt.setp(ax5.xaxis.get_majorticklabels(), rotation=45, ha=â€˜rightâ€™)</p>
</section>
<section id="summary-comparison-median-final-balance" class="level1">
<h1>3. Summary comparison: Median final balance</h1>
<p>ax6 = plt.subplot(3, 2, 6) medians = [np.median(results[f]) for f in betting_fractions] bars = ax6.bar(fraction_labels, medians, color=colors_bar, alpha=0.7, edgecolor=â€˜blackâ€™, linewidth=2) ax6.axhline(initial_wealth, color=â€˜redâ€™, linestyle=â€˜â€“â€™, linewidth=2, label=fâ€™Initial: <span class="math inline">\({initial_wealth:,}')
ax6.set_yscale('log')
ax6.set_ylabel('Median Final Balance (\)</span>, log scale)â€˜, fontsize=11) ax6.set_title(â€™Median Final Balance by Betting Fractionâ€™, fontsize=12, fontweight=â€˜boldâ€™) ax6.legend(fontsize=9) ax6.grid(True, which=â€˜bothâ€™, linestyle=â€˜â€“â€™, linewidth=0.5, alpha=0.3) plt.setp(ax6.xaxis.get_majorticklabels(), rotation=45, ha=â€˜rightâ€™)</p>
<p>plt.suptitle(â€˜Kelly Criterion Analysis: Impact of Betting Fraction on Final Wealth (75 Years)â€™, fontsize=14, fontweight=â€˜boldâ€™, y=0.995) plt.tight_layout() plt.show()</p>
</section>
<section id="print-comprehensive-comparison-table" class="level1">
<h1>Print comprehensive comparison table</h1>
<p>print(â€œâ€ + â€œ=â€ * 80) print(â€œKELLY CRITERION: COMPREHENSIVE COMPARISON OF BETTING FRACTIONSâ€) print(â€œ=â€ * 80) print(fâ€{â€˜Strategyâ€™:&lt;20} {â€˜Fractionâ€™:&lt;12} {â€˜Meanâ€™:&lt;15} {â€˜Medianâ€™:&lt;15} {â€˜P(&gt;$30k)â€™:&lt;12} {â€˜Kelly Ratioâ€™:&lt;12}â€œ) print(â€-â€ * 80) for i, fraction in enumerate(betting_fractions): data = results[fraction] mean_val = np.mean(data) median_val = np.median(data) prob_above = np.mean(data &gt; initial_wealth) kelly_ratio = fraction / kelly_fraction strategy_name = fraction_labels[i] print(fâ€{strategy_name:&lt;20} {fraction:&gt;6.0%} <span class="math inline">\({mean_val:&gt;12,.0f}   "
          f"\)</span>{median_val:&gt;12,.0f} {prob_above:&gt;10.1%} {kelly_ratio:&gt;6.1f}Ã—â€œ) print(â€=â€ * 80) print(fâ€Optimal Fraction: {kelly_fraction:.1%} (1.0Ã—)â€œ) print(â€Insights:â€œ) print(fâ€ â€¢ Original strategy (100%) is {1.0/kelly_fraction:.1f}Ã— the Kelly optimal â†’ EXTREMELY AGGRESSIVEâ€) print(fâ€ â€¢ Modified strategy (25%) is {0.25/kelly_fraction:.1f}Ã— the Kelly optimal â†’ Still overbettingâ€) print(fâ€ â€¢ Kelly optimal (10%) maximizes long-term growth rateâ€) print(â€œ:â€) print(â€ â€¢ Values &gt; 1.0Ã— are overbetting (too aggressive, higher volatility, lower median)â€œ) print(â€ â€¢ Values &lt; 1.0Ã— are underbetting (too conservative, lower growth potential)â€œ) print(â€ â€¢ Kelly optimal (1.0Ã—) balances growth and risk optimallyâ€) print(â€œ=â€ * 80)</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>